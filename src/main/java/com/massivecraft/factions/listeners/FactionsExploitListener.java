package com.massivecraft.factions.listeners;

import com.massivecraft.factions.FactionsPlugin;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockFromToEvent;
import org.bukkit.event.player.PlayerTeleportEvent;
import org.bukkit.inventory.ItemStack;

public final class FactionsExploitListener implements Listener {

    public final FactionsPlugin plugin;

    public FactionsExploitListener(final FactionsPlugin plugin) {
        this.plugin = plugin;
    }

    @EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
    public void obsidianGenerator(final BlockFromToEvent event) {
        if (!plugin.worldUtil().isEnabled(event.getBlock().getWorld())) {
            return;
        }

        if (!FactionsPlugin.getInstance().conf().exploits().isObsidianGenerators()) {
            return;
        }

        final Block block = event.getToBlock();
        final Material source = event.getBlock().getType();
        final Material target = block.getType();

        if ((target == Material.REDSTONE_WIRE || target == Material.TRIPWIRE) &&
            (source == Material.AIR || source == Material.LAVA)) {

            block.setType(Material.AIR);
        }
    }

    @EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
    public void enderPearlTeleport(final PlayerTeleportEvent event) {
        if (!plugin.worldUtil().isEnabled(event.getPlayer())) {
            return;
        }

        if (!FactionsPlugin.getInstance().conf().exploits().isEnderPearlClipping()) {
            return;
        }

        if (event.getCause() != PlayerTeleportEvent.TeleportCause.ENDER_PEARL) {
            return;
        }

        // this exploit works when the target location is within 0.31 blocks or so of a door or glass block
        // or similar...
        final Location to = event.getTo();
        final Location from = event.getFrom();
        final Material matTo = to.getBlock().getType();

        // blocks who occupy less than 1 block width or length wise need to be handled differently
        if ((matTo == Material.THIN_GLASS || matTo == Material.IRON_FENCE) &&
            clippedThrough(to.getX(), to.getZ(), from.getX(), from.getZ(), 0.65D) ||
            (matTo == Material.FENCE || matTo == Material.NETHER_FENCE) &&
                clippedThrough(to.getX(), to.getZ(), from.getX(), from.getZ(), 0.45D)) {

            event.setCancelled(true);
            return;
        }

        // set to center of block
        to.setX(to.getBlockX() + 0.5D);
        to.setZ(to.getBlockZ() + 0.5D);

        // check if pearling into block
        if (matTo != Material.AIR) {
            // TODO: editable message
            event.getPlayer().sendMessage(ChatColor.RED.toString() + "Cannot enderpearl here.");
            event.getPlayer().getInventory().addItem(new ItemStack(Material.ENDER_PEARL));
            event.setCancelled(true);
            return;
        }

        final Location toClone = to.clone();
        final Material matAbove = toClone.add(0, 1D, 0).getBlock().getType();
        final Material matBelow = toClone.subtract(0, 2D, 0).getBlock().getType();

        // check if pearling into 1x1
        if (matAbove != Material.AIR && matBelow != Material.AIR) {
            // TODO: editable message
            event.getPlayer().sendMessage(ChatColor.RED.toString() + "Cannot enderpearl here.");
            event.getPlayer().getInventory().addItem(new ItemStack(Material.ENDER_PEARL));
            event.setCancelled(true);
            return;
        }

        event.setTo(to);
    }

    private static boolean clippedThrough(final double toX, final double toZ, final double fromX,
                                           final double fromZ,
                                           final double thickness) {

        return (fromX > toX && (fromX - toX < thickness)) || (toX > fromX && (toX - fromX < thickness)) ||
            (fromZ > toZ && (fromZ - toZ < thickness)) || (toZ > fromZ && (toZ - fromZ < thickness));
    }

}
